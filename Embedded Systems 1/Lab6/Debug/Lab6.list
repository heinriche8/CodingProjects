
Lab6.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001c4  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00000830  080001c4  080001c4  000101c4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000006c  080009f4  080009f4  000109f4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08000a60  08000a60  00020004  2**0
                  CONTENTS
  4 .ARM          00000000  08000a60  08000a60  00020004  2**0
                  CONTENTS
  5 .preinit_array 00000000  08000a60  08000a60  00020004  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08000a60  08000a60  00010a60  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08000a64  08000a64  00010a64  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000004  20000000  08000a68  00020000  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          0000001c  20000004  08000a6c  00020004  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  20000020  08000a6c  00020020  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00020004  2**0
                  CONTENTS, READONLY
 12 .debug_line   00000516  00000000  00000000  00020034  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_info   0000012c  00000000  00000000  0002054a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 0000009e  00000000  00000000  00020676  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00000108  00000000  00000000  00020718  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_str    000000d3  00000000  00000000  00020820  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_ranges 00000020  00000000  00000000  000208f8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_frame  0000002c  00000000  00000000  00020918  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001c4 <__do_global_dtors_aux>:
 80001c4:	b510      	push	{r4, lr}
 80001c6:	4c05      	ldr	r4, [pc, #20]	; (80001dc <__do_global_dtors_aux+0x18>)
 80001c8:	7823      	ldrb	r3, [r4, #0]
 80001ca:	b933      	cbnz	r3, 80001da <__do_global_dtors_aux+0x16>
 80001cc:	4b04      	ldr	r3, [pc, #16]	; (80001e0 <__do_global_dtors_aux+0x1c>)
 80001ce:	b113      	cbz	r3, 80001d6 <__do_global_dtors_aux+0x12>
 80001d0:	4804      	ldr	r0, [pc, #16]	; (80001e4 <__do_global_dtors_aux+0x20>)
 80001d2:	f3af 8000 	nop.w
 80001d6:	2301      	movs	r3, #1
 80001d8:	7023      	strb	r3, [r4, #0]
 80001da:	bd10      	pop	{r4, pc}
 80001dc:	20000004 	.word	0x20000004
 80001e0:	00000000 	.word	0x00000000
 80001e4:	080009dc 	.word	0x080009dc

080001e8 <frame_dummy>:
 80001e8:	b508      	push	{r3, lr}
 80001ea:	4b03      	ldr	r3, [pc, #12]	; (80001f8 <frame_dummy+0x10>)
 80001ec:	b11b      	cbz	r3, 80001f6 <frame_dummy+0xe>
 80001ee:	4903      	ldr	r1, [pc, #12]	; (80001fc <frame_dummy+0x14>)
 80001f0:	4803      	ldr	r0, [pc, #12]	; (8000200 <frame_dummy+0x18>)
 80001f2:	f3af 8000 	nop.w
 80001f6:	bd08      	pop	{r3, pc}
 80001f8:	00000000 	.word	0x00000000
 80001fc:	20000008 	.word	0x20000008
 8000200:	080009dc 	.word	0x080009dc

08000204 <num_to_ASCII>:
//		R4	-	Tens
//		R5	-	Hundreds
//		R6	-	Thousands
//		R7	-	Mask
num_to_ASCII:
	PUSH {R1-R12, LR}	// Backup registers
 8000204:	e92d 5ffe 	stmdb	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}

	LDR R2, =MAX_VALUE	// Load max value
 8000208:	f242 720f 	movw	r2, #9999	; 0x270f
	CMP R1, R2			// Compare the argument to the maximum value
 800020c:	4291      	cmp	r1, r2
	BGE error			// Return the error code if the argument is larger than the max.
 800020e:	da36      	bge.n	800027e <error>
	MOV R2, R1			// Copy the argument for modification
 8000210:	460a      	mov	r2, r1

	MOV R6, #0			// Clear thousands counter
 8000212:	f04f 0600 	mov.w	r6, #0

08000216 <mod1000>:
mod1000:
	SUBS R2, R2, #0x3E8	// Subtract 1000, update flags
 8000216:	f5b2 727a 	subs.w	r2, r2, #1000	; 0x3e8
	ITET PL					// If positive
 800021a:	bf56      	itet	pl
		ADDPL R6, R6, #1	// Increment thousands counter
 800021c:	3601      	addpl	r6, #1
		ADDMI R2, R2, #0x3E8// Add back 1000 if negative
 800021e:	f502 727a 	addmi.w	r2, r2, #1000	; 0x3e8
		BPL mod1000			// Otherwise continue looping
 8000222:	e7f8      	bpl.n	8000216 <mod1000>

	MOV R5, #0			// Clear hundreds counter
 8000224:	f04f 0500 	mov.w	r5, #0

08000228 <mod100>:
mod100:
	SUBS R2, R2, #0x64	// Subtract 100, update flags
 8000228:	3a64      	subs	r2, #100	; 0x64
	ITET PL					//If positive
 800022a:	bf56      	itet	pl
		ADDPL R5, R5, #1	// Increment hundreds counter
 800022c:	3501      	addpl	r5, #1
		ADDMI R2, R2, #0x64	// Add back 100 if negative
 800022e:	3264      	addmi	r2, #100	; 0x64
		BPL mod100			// Otherwise continue looping
 8000230:	e7fa      	bpl.n	8000228 <mod100>

	MOV R4, #0			// Clear tens register
 8000232:	f04f 0400 	mov.w	r4, #0

08000236 <mod10>:
mod10:
	SUBS R2, R2, #0xA	// Subtract 10, update flags
 8000236:	3a0a      	subs	r2, #10
	ITET PL					// If positive
 8000238:	bf56      	itet	pl
		ADDPL R4, R4, #1	// Increment tens counter
 800023a:	3401      	addpl	r4, #1
		ADDMI R2, R2, #0xA	// Add back 10 if negative
 800023c:	320a      	addmi	r2, #10
		BPL mod10			// Otherwise continue looping
 800023e:	e7fa      	bpl.n	8000236 <mod10>

	MOV R3, R2			// Whatever is left is the ones place
 8000240:	4613      	mov	r3, r2
	MOV R2, #0			// Clear register 2
 8000242:	f04f 0200 	mov.w	r2, #0

	MOV R7, #0x30		// Load mask for numeric ASCII values
 8000246:	f04f 0730 	mov.w	r7, #48	; 0x30

	ORR R2, R2, R7		// Apply base mask
 800024a:	ea42 0207 	orr.w	r2, r2, r7
	ORR R2, R2, R6		// Apply thousands place
 800024e:	ea42 0206 	orr.w	r2, r2, r6
	LSL R2, R2, #8		// Shift left 8 for the hundreds place
 8000252:	ea4f 2202 	mov.w	r2, r2, lsl #8
	ORR R2, R2, R7		// Apply base mask
 8000256:	ea42 0207 	orr.w	r2, r2, r7
	ORR R2, R2, R5		// Apply hundreds place
 800025a:	ea42 0205 	orr.w	r2, r2, r5
	LSL R2, R2, #8		// Shift left 8 more for the tens place
 800025e:	ea4f 2202 	mov.w	r2, r2, lsl #8
	ORR R2, R2, R7		// Apply base mask
 8000262:	ea42 0207 	orr.w	r2, r2, r7
	ORR R2, R2, R4		// Apply tens place
 8000266:	ea42 0204 	orr.w	r2, r2, r4
	LSL R2, R2, #8		// Shift left last 8 time for the ones place
 800026a:	ea4f 2202 	mov.w	r2, r2, lsl #8
	ORR R2, R2, R7		// Apply base mask
 800026e:	ea42 0207 	orr.w	r2, r2, r7
	ORR R2, R2, R3		// Apply ones place
 8000272:	ea42 0203 	orr.w	r2, r2, r3

	MOV R0, R2			// Move return value
 8000276:	4610      	mov	r0, r2

	POP {R1-R12, LR}	// Restore registers
 8000278:	e8bd 5ffe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
	BX LR
 800027c:	4770      	bx	lr

0800027e <error>:

	error:
	LDR R0, =ERR
 800027e:	4818      	ldr	r0, [pc, #96]	; (80002e0 <ASCII_StringLength+0x12>)
	POP {R1-R12, LR}
 8000280:	e8bd 5ffe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
	BX LR
 8000284:	4770      	bx	lr

08000286 <ASCII_StringCompare>:
//		R3	-	Iterator
//		R5	-	Backup of String1 length
//		R6	-	Backup of String1 addr
//		R7	-	Backup of String2 addr
ASCII_StringCompare:
	PUSH {R1-R3, R5-R7, LR}
 8000286:	b5ee      	push	{r1, r2, r3, r5, r6, r7, lr}

	// Backup addresses
	MOV R6, R1
 8000288:	460e      	mov	r6, r1
	MOV R7, R2
 800028a:	4617      	mov	r7, r2

	// Get lengths of strings
	BL ASCII_StringLength	// Length of first string
 800028c:	f000 f81f 	bl	80002ce <ASCII_StringLength>
	MOV R5, R0				// Move length into a temp register
 8000290:	4605      	mov	r5, r0
	MOV R1, R2				// Move second string into arg register
 8000292:	4611      	mov	r1, r2
	BL ASCII_StringLength	// Length of second string
 8000294:	f000 f81b 	bl	80002ce <ASCII_StringLength>
	MOV R2, R0				// Move length into R2
 8000298:	4602      	mov	r2, r0
	MOV R1, R5				// Move backup of string 1 length into R1
 800029a:	4629      	mov	r1, r5

	// Compare lengths of strings
	CMP R1, R2				// Compare lengths
 800029c:	4291      	cmp	r1, r2
	ITT GT					// If R1 > R2
 800029e:	bfc4      	itt	gt
		MOVGT R0, #1		// Load 1 into the return register, aka not equal
 80002a0:	2001      	movgt	r0, #1
		BGT return			// Return
 80002a2:	e013      	bgt.n	80002cc <return>
	ITT LT					// If R1 < R2
 80002a4:	bfbc      	itt	lt
		MOVLT R0, #1		// Load 1 into the return register, aka not equal
 80002a6:	2001      	movlt	r0, #1
		BLT return			// Return
 80002a8:	e010      	blt.n	80002cc <return>
	// Now the difficult part. At this point, the strings are the same
	// length, so we need to iterate through the string and compare each char.
	// This is also the final stage of the comparison, so make sure R0 is
	// ready to return.

	MOV R0, #0				// Clear return register
 80002aa:	f04f 0000 	mov.w	r0, #0
	MOV R3, #0				// Clear an iterator
 80002ae:	f04f 0300 	mov.w	r3, #0
	MOV R1, R6				// Restore first address
 80002b2:	4631      	mov	r1, r6
	MOV R2, R7				// Restore second address
 80002b4:	463a      	mov	r2, r7

	1:
	LDRB R6, [R1, R3]		// Load into a temp register the char at index R3
 80002b6:	5cce      	ldrb	r6, [r1, r3]
	LDRB R7, [R2, R3]		// Load into a temp register the char at index R3
 80002b8:	5cd7      	ldrb	r7, [r2, r3]
	CMP R6, R7				// Compare the two chars
 80002ba:	42be      	cmp	r6, r7
	ITT NE					// If the chars are not equal
 80002bc:	bf1c      	itt	ne
		MOVNE R0, #1		// Load 1 into the return register, aka not equal
 80002be:	2001      	movne	r0, #1
		BNE return			// Return
 80002c0:	e004      	bne.n	80002cc <return>

	ADD R3, #1				// Increment iterator
 80002c2:	f103 0301 	add.w	r3, r3, #1
	CMP R3, R5				// Compare incremented iterator to string length
 80002c6:	42ab      	cmp	r3, r5
	BGT return				// If the iterator is greater than the string length, return
 80002c8:	dc00      	bgt.n	80002cc <return>
							// That means all of the chars were equal.

	B 1b					// Otherwise keep looping
 80002ca:	e7f4      	b.n	80002b6 <ASCII_StringCompare+0x30>

080002cc <return>:

	return:
	POP {R1-R3, R5-R7, PC}
 80002cc:	bdee      	pop	{r1, r2, r3, r5, r6, r7, pc}

080002ce <ASCII_StringLength>:
//	Returns:
//		R0	-	Length
//	Register Use:
//
ASCII_StringLength:
	PUSH {R1, R2, LR}
 80002ce:	b506      	push	{r1, r2, lr}

	MOV R0, #0			// Clear iterator
 80002d0:	f04f 0000 	mov.w	r0, #0

1:
	LDRB R2, [R1, R0]	// Load character at index R0
 80002d4:	5c0a      	ldrb	r2, [r1, r0]
	CMP R2, #0			// Determine if the char is null
 80002d6:	2a00      	cmp	r2, #0
	ITT NE
 80002d8:	bf1c      	itt	ne
		ADDNE R0, #1	// Increment iterator if not zero
 80002da:	3001      	addne	r0, #1
		BNE 1b
 80002dc:	e7fa      	bne.n	80002d4 <ASCII_StringLength+0x6>

	POP {R1, R2, PC}
 80002de:	bd06      	pop	{r1, r2, pc}
	LDR R0, =ERR
 80002e0:	4572722e 	.word	0x4572722e

080002e4 <PortSetup>:
//		R1	-	Addresses
//		R2	-	Scratch
//		R3	-	Masks
PortSetup:
	// Backup Registers
    PUSH {R1-R3, LR}
 80002e4:	b50e      	push	{r1, r2, r3, lr}

	// Enable GPIO Ports A & C
    LDR R1, =RCC_BASE			// Load RCC base address
 80002e6:	496c      	ldr	r1, [pc, #432]	; (8000498 <LCD_PrintChar+0x8>)
    LDR R2, [R1, #RCC_AHB1ENR]	// Read from the AHB1 Enable Register
 80002e8:	6b0a      	ldr	r2, [r1, #48]	; 0x30
    ORR R2, R2, #RCC_GPIOAEN	// Apply GPIOA Enable mask
 80002ea:	f042 0201 	orr.w	r2, r2, #1
    ORR R2, R2, #RCC_GPIOCEN	// Apply GPIOC Enable mask
 80002ee:	f042 0204 	orr.w	r2, r2, #4
    STR R2, [R1, #RCC_AHB1ENR]	// Write back to memory
 80002f2:	630a      	str	r2, [r1, #48]	; 0x30

    // Set GPIOA Pins as output (PA4-PA11)
    LDR R1, =GPIOA_BASE			// Load GPIOA base address
 80002f4:	4969      	ldr	r1, [pc, #420]	; (800049c <LCD_PrintChar+0xc>)
    LDR R3, =0x00555500			// Load mode mask
 80002f6:	4b6a      	ldr	r3, [pc, #424]	; (80004a0 <LCD_PrintChar+0x10>)
    LDR R2, [R1, #GPIO_MODER]	// Read
 80002f8:	680a      	ldr	r2, [r1, #0]
    ORR R2, R3					// Apply mode mask
 80002fa:	ea42 0203 	orr.w	r2, r2, r3
    STR R2, [R1, #GPIO_MODER]	// Write
 80002fe:	600a      	str	r2, [r1, #0]

    // Set GPIOC Pins as output (PC8-PC10)
    LDR R1, =GPIOC_BASE			// Load GPIOC base address
 8000300:	4968      	ldr	r1, [pc, #416]	; (80004a4 <LCD_PrintChar+0x14>)
    LDR R3, =0x00550000			// Load mode mask
 8000302:	f44f 03aa 	mov.w	r3, #5570560	; 0x550000
    LDR R2, [R1, #GPIO_MODER]	// Read
 8000306:	680a      	ldr	r2, [r1, #0]
    ORR R2, R3					// Apply mode mask
 8000308:	ea42 0203 	orr.w	r2, r2, r3
    STR R2, [R1, #GPIO_MODER]	// Write
 800030c:	600a      	str	r2, [r1, #0]

	POP {R1-R3, LR}			// Restore
 800030e:	e8bd 400e 	ldmia.w	sp!, {r1, r2, r3, lr}
    BX LR						// Return
 8000312:	4770      	bx	lr

08000314 <WriteInstruction>:
//		R2	-	Scratch
//		R3	-	GPIOC Address
//		R4	-	GPIOA Address
//		R7	-	Masks
WriteInstruction:
	PUSH {R1-R4, R7, LR}			// Backup registers
 8000314:	b59e      	push	{r1, r2, r3, r4, r7, lr}

	LDR R3, =GPIOC_BASE			// Load GPIO port C address
 8000316:	4b63      	ldr	r3, [pc, #396]	; (80004a4 <LCD_PrintChar+0x14>)
	LDR R4, =GPIOA_BASE			// Load GPIO port A address
 8000318:	4c60      	ldr	r4, [pc, #384]	; (800049c <LCD_PrintChar+0xc>)

	// Clear RS, RW, E
	LDR R2, [R3, #GPIO_ODR]	// Read
 800031a:	695a      	ldr	r2, [r3, #20]
	BIC R2, #RS				// Apply RS set mask
 800031c:	f422 7280 	bic.w	r2, r2, #256	; 0x100
	BIC R2, #RW				// Apply RW set mask
 8000320:	f422 7200 	bic.w	r2, r2, #512	; 0x200
	BIC R2, #E				// Apply E clear mask
 8000324:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
	STR R2, [R3, #GPIO_ODR]	// Write
 8000328:	615a      	str	r2, [r3, #20]

	// Set E, E => 1
	LDR R2, [R3, #GPIO_ODR]	// Read
 800032a:	695a      	ldr	r2, [r3, #20]
	ORR R2, #E				// Apply E set mask
 800032c:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
	STR R2, [R3, #GPIO_ODR]	// Write
 8000330:	615a      	str	r2, [r3, #20]

	// Push the instruction onto the data bus
	LDR R2, [R3, #GPIO_ODR]	// Read
 8000332:	695a      	ldr	r2, [r3, #20]
	BFI R2, R1, #4, #8		// Insert instruction
 8000334:	f361 120b 	bfi	r2, r1, #4, #8
	STR R2, [R4, #GPIO_ODR]	// Write to BSRR
 8000338:	6162      	str	r2, [r4, #20]
	
	// Clear E, E => 0
	LDR R2, [R3, #GPIO_ODR]	// Read
 800033a:	695a      	ldr	r2, [r3, #20]
	BIC R2, #E				// Apply E clear mask
 800033c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
	STR R2, [R3, #GPIO_ODR]	// Write
 8000340:	615a      	str	r2, [r3, #20]

	//	Wait for appropriate delay
	//	->	Listed delay for holding instructions on the bus after E falls
	//		is 10ns, when the next instruction takes more than 60ns

	POP {R1-R4, R7, PC}			// Restore & Return
 8000342:	bd9e      	pop	{r1, r2, r3, r4, r7, pc}

08000344 <WriteData>:
//		R3	-	GPIOC Address
//		R4	-	GPIOA Address
//		R7	-	Masks
// RS=0 RW=0  R1-Arg
WriteData:
	PUSH {R1-R4, R7, LR}	// Backup
 8000344:	b59e      	push	{r1, r2, r3, r4, r7, lr}
	LDR R3, =GPIOC_BASE	// Load GPIOC address
 8000346:	4b57      	ldr	r3, [pc, #348]	; (80004a4 <LCD_PrintChar+0x14>)
	LDR R4, =GPIOA_BASE	// Load GPIOA address
 8000348:	4c54      	ldr	r4, [pc, #336]	; (800049c <LCD_PrintChar+0xc>)

	// Set RS=1,RW=0,E=0
	LDR R2, [R3, #GPIO_ODR]	// Read
 800034a:	695a      	ldr	r2, [r3, #20]
	BIC R2, #E				// Apply E clear mask
 800034c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
	ORR R2, #RS				// Apply RS set mask
 8000350:	f442 7280 	orr.w	r2, r2, #256	; 0x100
	BIC R2, #RW				// Apply RW clear mask
 8000354:	f422 7200 	bic.w	r2, r2, #512	; 0x200
	STR R2, [R3, #GPIO_ODR]	// Write
 8000358:	615a      	str	r2, [r3, #20]

	// Set E=1
	LDR R2, [R3, #GPIO_ODR]	// Read
 800035a:	695a      	ldr	r2, [r3, #20]
	ORR R2, #E				// Apply E set mask
 800035c:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
	STR R2, [R3, #GPIO_ODR]	// Write to BSRR
 8000360:	615a      	str	r2, [r3, #20]

	// Set R1 -> DataBus (PA4-PA11)
	LDR R2, [R3, #GPIO_ODR]	// Read
 8000362:	695a      	ldr	r2, [r3, #20]
	BFI R2, R1, #4, #8		// Insert data onto bus
 8000364:	f361 120b 	bfi	r2, r1, #4, #8
	STR R2, [R4, #GPIO_ODR]	// Write
 8000368:	6162      	str	r2, [r4, #20]

	// Set E=0
	MOV R2, #0				// Clear scratch register
 800036a:	f04f 0200 	mov.w	r2, #0
	BIC R2, #E				// Apply E clear mask
 800036e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
	STR R2, [R3, #GPIO_ODR]	// Write to BSRR
 8000372:	615a      	str	r2, [r3, #20]

	// >37us delay
	MOV R1, #40
 8000374:	f04f 0128 	mov.w	r1, #40	; 0x28
	BL delay_us
 8000378:	f000 fa46 	bl	8000808 <delay_us>

	POP {R1-R4, R7, PC}
 800037c:	bd9e      	pop	{r1, r2, r3, r4, r7, pc}

0800037e <LCD_Init>:
//	Returns:
//		N/A
//	Register Use:
//		R1	-	Instructions/Commands
LCD_Init:
	PUSH {R1, LR}	// Backup registers
 800037e:	b502      	push	{r1, lr}

    BL PortSetup		// Configure GPIO ports
 8000380:	f7ff ffb0 	bl	80002e4 <PortSetup>

    // Write Function Set (0x38)
    MOV R1, #0x38		// Load instruction
 8000384:	f04f 0138 	mov.w	r1, #56	; 0x38
    BL WriteInstruction	// Write instruction
 8000388:	f7ff ffc4 	bl	8000314 <WriteInstruction>

    MOV R1, #40			// >37us delay after prev. command
 800038c:	f04f 0128 	mov.w	r1, #40	; 0x28
    BL delay_us			// Execute delay
 8000390:	f000 fa3a 	bl	8000808 <delay_us>

    // Write Function Set (0x38)
    MOV R1, #0x38		// Load instruction
 8000394:	f04f 0138 	mov.w	r1, #56	; 0x38
    BL WriteInstruction	// Write instruction
 8000398:	f7ff ffbc 	bl	8000314 <WriteInstruction>

    MOV R1, #40			// >37us delay after prev. command
 800039c:	f04f 0128 	mov.w	r1, #40	; 0x28
    BL delay_us			// Execute delay
 80003a0:	f000 fa32 	bl	8000808 <delay_us>

    // Write Display On/Off(0x0F)
    MOV R1, #0x0F		// Load instruction
 80003a4:	f04f 010f 	mov.w	r1, #15
    BL WriteInstruction	// Write instruction
 80003a8:	f7ff ffb4 	bl	8000314 <WriteInstruction>

    MOV R1, #40			// >37us delay after prev. command
 80003ac:	f04f 0128 	mov.w	r1, #40	; 0x28
    BL delay_us			// Execute delay
 80003b0:	f000 fa2a 	bl	8000808 <delay_us>

    // Write Display Clear (0x01)
    MOV R1, 0x01		// Load instruction
 80003b4:	f04f 0101 	mov.w	r1, #1
    BL WriteInstruction	// Execute instruction
 80003b8:	f7ff ffac 	bl	8000314 <WriteInstruction>

    MOV R1, #2			// >1.52ms delay after prev. command
 80003bc:	f04f 0102 	mov.w	r1, #2
    BL delay_ms			// Execute delay
 80003c0:	f000 fa10 	bl	80007e4 <delay_ms>

    #Write Entry Mode Set (0x06)
    MOV R1, #0x06		// Load instruction
 80003c4:	f04f 0106 	mov.w	r1, #6
    BL WriteInstruction	// Execute instruction
 80003c8:	f7ff ffa4 	bl	8000314 <WriteInstruction>

	MOV R1, #40			// >37us delay after prev. command
 80003cc:	f04f 0128 	mov.w	r1, #40	; 0x28
	BL delay_us			// Execute delay
 80003d0:	f000 fa1a 	bl	8000808 <delay_us>

	POP {R1, PC}
 80003d4:	bd02      	pop	{r1, pc}

080003d6 <LCD_Clear>:
//	Returns:
//		N/A
//	Register Use:
//		R1	-	Instruction & Delay
LCD_Clear:
	PUSH {R1, LR}		// Backup registers
 80003d6:	b502      	push	{r1, lr}

	MOV R1, #0x01			// Load instruction
 80003d8:	f04f 0101 	mov.w	r1, #1
	BL WriteInstruction		// Execute instruction
 80003dc:	f7ff ff9a 	bl	8000314 <WriteInstruction>

	MOV R1, #2				// Load delay
 80003e0:	f04f 0102 	mov.w	r1, #2
	BL delay_ms				// Execute delay
 80003e4:	f000 f9fe 	bl	80007e4 <delay_ms>

	POP {R1, PC}		// Restore & return
 80003e8:	bd02      	pop	{r1, pc}

080003ea <LCD_Home>:
//	Returns:
//		N/A
//	Register Use:
//		R1	-	Instructions & Delay
LCD_Home:
	PUSH {R1, LR}		// Backup registers
 80003ea:	b502      	push	{r1, lr}

	MOV R1, #0x02			// Load instruction
 80003ec:	f04f 0102 	mov.w	r1, #2
	BL WriteInstruction		// Execute instruction
 80003f0:	f7ff ff90 	bl	8000314 <WriteInstruction>

	MOV R1, #2				// Load delay
 80003f4:	f04f 0102 	mov.w	r1, #2
	BL delay_ms				// Execute delay
 80003f8:	f000 f9f4 	bl	80007e4 <delay_ms>

	POP {R1, PC}		// Restore & return
 80003fc:	bd02      	pop	{r1, pc}

080003fe <LCD_MoveCursor>:
//		R0	-	Argument
//		R1	-	Argument
//		R7	-	Scratch
//		R6	-	Command mask
LCD_MoveCursor:
	PUSH {R0-R1, R6-R7, LR}
 80003fe:	b5c3      	push	{r0, r1, r6, r7, lr}
	MOV R7, #0			// Clear scratch register
 8000400:	f04f 0700 	mov.w	r7, #0
	MOV R6, #0			// Command register
 8000404:	f04f 0600 	mov.w	r6, #0

	CMP R0, #0			// Determine if in top row
 8000408:	2800      	cmp	r0, #0
	IT NE
 800040a:	bf18      	it	ne
		MOVNE R7, #0x40	// Load second row mask if in bottom row
 800040c:	2740      	movne	r7, #64	; 0x40

	ORR R7, R7, R1		// Apply mask
 800040e:	ea47 0701 	orr.w	r7, r7, r1
						// This gives us the desired address

	MOV R6, #0x80 		// Load command mask, 0b10000000
 8000412:	f04f 0680 	mov.w	r6, #128	; 0x80
	ORR R1, R6, R7		// Apply mask to desired address
 8000416:	ea46 0107 	orr.w	r1, r6, r7
	// This should make the command be 0b1aaaaaaa where
	// all of the a's represent the address of the desired
	// location. Result is stored in R1, so we just call
	// the method that pushes instructions

	BL WriteInstruction	// Push instruction to the LCD
 800041a:	f7ff ff7b 	bl	8000314 <WriteInstruction>

	MOV R1, #40			// >37us delay for moving cursor
 800041e:	f04f 0128 	mov.w	r1, #40	; 0x28
	BL delay_us			// Execute delay
 8000422:	f000 f9f1 	bl	8000808 <delay_us>

	POP {R0-R1, R6-R7, PC}
 8000426:	bdc3      	pop	{r0, r1, r6, r7, pc}

08000428 <LCD_PrintString>:
//	Register Use:
//		R0	-	Return
//		R1	-	Argument
//		R2	-	Current character
LCD_PrintString:
	PUSH {R1-R2, LR}	// We don't need to back up R0 because it is a return
 8000428:	b506      	push	{r1, r2, lr}
	MOV R0, #0			// Iterator value
 800042a:	f04f 0000 	mov.w	r0, #0

0800042e <loop>:

	// Determine the length of the string
loop:
	LDRB R2, [R1, R0]	// Load character from the string with offset R0
 800042e:	5c0a      	ldrb	r2, [r1, r0]
	CMP R2, #0			// Determine if the character is null
 8000430:	2a00      	cmp	r2, #0
	ITTTT NE			// If the character isn't null
 8000432:	bf1f      	itttt	ne
		ADDNE R0, #1	// Increment the iterator
 8000434:	3001      	addne	r0, #1
		PUSHNE {R1}		// Backup the address
 8000436:	b402      	pushne	{r1}
		MOVNE R1, R2	// Move the character into R1
 8000438:	4611      	movne	r1, r2
		BLNE WriteData	// Write the character
 800043a:	f7ff ff83 	blne	8000344 <WriteData>

	// Because I built the delay for writing characters into WriteData,
	// the condition flags get updated making the next IT block inaccurate
	// so I need to redo the original comparisons to fix the PSR

	CMP R2, #0
 800043e:	2a00      	cmp	r2, #0
	ITT NE
 8000440:	bf1c      	itt	ne
		POPNE {R1}		// Restore address
 8000442:	bc02      	popne	{r1}
		BNE loop		// Loop until we hit a null char
 8000444:	e7f3      	bne.n	800042e <loop>

	POP {R1-R2, PC}	// Restore & return
 8000446:	bd06      	pop	{r1, r2, pc}

08000448 <LCD_PrintNum>:
//	Register Use:
//		R0	-	ASCII String
//		R1	-	Argument
//		R2	-	Mask
LCD_PrintNum:
	PUSH {R0-R2, LR}
 8000448:	b507      	push	{r0, r1, r2, lr}

	BL num_to_ASCII 	// Stores ASCII representing chars in R0
 800044a:	f7ff fedb 	bl	8000204 <num_to_ASCII>
	MOV R1, #0			// Clear R1 so we can use it for WriteData
 800044e:	f04f 0100 	mov.w	r1, #0
	MOV R2, #0xFF000000	// Base mask for characters
 8000452:	f04f 427f 	mov.w	r2, #4278190080	; 0xff000000

	AND R1, R0, R2		// Mask off all but first char
 8000456:	ea00 0102 	and.w	r1, r0, r2
	LSR R1, R1, #24		// Move char into correct position
 800045a:	ea4f 6111 	mov.w	r1, r1, lsr #24
	BL WriteData		// Write char
 800045e:	f7ff ff71 	bl	8000344 <WriteData>

	LSR R2, R2, #8		// Shift mask right by one char
 8000462:	ea4f 2212 	mov.w	r2, r2, lsr #8
	AND R1, R0, R2		// Apply mask
 8000466:	ea00 0102 	and.w	r1, r0, r2
	LSR R1, R1, #16		// Move char into correct position
 800046a:	ea4f 4111 	mov.w	r1, r1, lsr #16
	BL WriteData		// Write char
 800046e:	f7ff ff69 	bl	8000344 <WriteData>

	LSR R2, R2, #8		// Shift mask right by one char
 8000472:	ea4f 2212 	mov.w	r2, r2, lsr #8
	AND R1, R0, R2		// Apply mask
 8000476:	ea00 0102 	and.w	r1, r0, r2
	LSR R1, R1, #8		// Move char into correct position
 800047a:	ea4f 2111 	mov.w	r1, r1, lsr #8
	BL WriteData		// Write char
 800047e:	f7ff ff61 	bl	8000344 <WriteData>

	LSR R2, R2, #8		// Shift mask left by one char
 8000482:	ea4f 2212 	mov.w	r2, r2, lsr #8
	AND R1, R0, R2		// Apply mask
 8000486:	ea00 0102 	and.w	r1, r0, r2
	BL WriteData		// Write char
 800048a:	f7ff ff5b 	bl	8000344 <WriteData>

	POP {R0-R2, PC}
 800048e:	bd07      	pop	{r0, r1, r2, pc}

08000490 <LCD_PrintChar>:
//	Returns:
//		N/A
//	Register Use:
//		R1	-	Argument
LCD_PrintChar:
	PUSH {LR}
 8000490:	b500      	push	{lr}

	BL WriteData
 8000492:	f7ff ff57 	bl	8000344 <WriteData>

	POP {PC}
 8000496:	bd00      	pop	{pc}
    LDR R1, =RCC_BASE			// Load RCC base address
 8000498:	40023800 	.word	0x40023800
    LDR R1, =GPIOA_BASE			// Load GPIOA base address
 800049c:	40020000 	.word	0x40020000
    LDR R3, =0x00555500			// Load mode mask
 80004a0:	00555500 	.word	0x00555500
    LDR R1, =GPIOC_BASE			// Load GPIOC base address
 80004a4:	40020800 	.word	0x40020800

080004a8 <LED_Init>:
//	Register Use:
//		R1	-	Current main address
//		R2	-	Working register where masks will be applied to
//		R3	-	Masks
LED_Init:
	PUSH {R0-R12, LR}			// Backup registers
 80004a8:	e92d 5fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}

	// Enable RCC For GPIOB
	LDR R1, =RCC_BASE			// Load the RCC base address
 80004ac:	4912      	ldr	r1, [pc, #72]	; (80004f8 <num_to_LED+0x2a>)
	LDR R2, [R1, #RCC_AHB1ENR]	// Load what is currently stored in the AHB1 Enabler
 80004ae:	6b0a      	ldr	r2, [r1, #48]	; 0x30
	ORR R2, R2, #GPIOBEN		// Apply the mask to enable GPIOB
 80004b0:	f042 0202 	orr.w	r2, r2, #2
	STR R2, [R1, #RCC_AHB1ENR]	// Write back the new AHB1 Enabler value
 80004b4:	630a      	str	r2, [r1, #48]	; 0x30

	// Set GPIOB Pins as Output
	LDR R1, =GPIOB_BASE 		// Load base address
 80004b6:	4911      	ldr	r1, [pc, #68]	; (80004fc <num_to_LED+0x2e>)
	LDR R2, [R1, #GPIOB_MODER]	// Load the GPIOB mode status
 80004b8:	680a      	ldr	r2, [r1, #0]
	LDR R3, =0xFF3FFC00			// Load the output clearing mask
 80004ba:	4b11      	ldr	r3, [pc, #68]	; (8000500 <num_to_LED+0x32>)
	BIC R2, R2, R3				// Clear the modes
 80004bc:	ea22 0203 	bic.w	r2, r2, r3
	LDR R3, =0x55155400			// Load the output setting mask
 80004c0:	4b10      	ldr	r3, [pc, #64]	; (8000504 <num_to_LED+0x36>)
	ORR R2, R2, R3				// Overwrite with output set mask
 80004c2:	ea42 0203 	orr.w	r2, r2, r3
	STR R2, [R1, #GPIOB_MODER]	// Write back to memory
 80004c6:	600a      	str	r2, [r1, #0]

	POP {R0-R12, LR}			// Restore registers
 80004c8:	e8bd 5fff 	ldmia.w	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
	BX LR						// Return from subroutine
 80004cc:	4770      	bx	lr

080004ce <num_to_LED>:
//		R1 	- 	Argument
//		R2	-	Working register; will contain the desired contents of the ODR
//		R3	-	Scratch/Addresses
//		R4 	- 	Masks/Offsets
num_to_LED:
	PUSH {R0-R12, LR}	// Backup registers
 80004ce:	e92d 5fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
	MOV R2, #0			// Clear register 2 since it stores the modified value
 80004d2:	f04f 0200 	mov.w	r2, #0

	LDR R4, =0xFFFFFC00	// Mask to clear all but lower then bits
 80004d6:	4c0c      	ldr	r4, [pc, #48]	; (8000508 <num_to_LED+0x3a>)
	BIC R3, R1, R4		// Apply the mask to Register 1 and store the result in a scratch register
 80004d8:	ea21 0304 	bic.w	r3, r1, r4

	BFI R2, R3, #5, #6	// Insert the lower portion of the pattern from R3 into R2
 80004dc:	f363 124a 	bfi	r2, r3, #5, #6
	LSR R3, R3, #6		// Shift the number left 6 times, giving us the last 4 bits in R3[0..3]
 80004e0:	ea4f 1393 	mov.w	r3, r3, lsr #6
	BFI R2, R3, #12, #4	// Insert the upper portion
 80004e4:	f363 320f 	bfi	r2, r3, #12, #4

	LDR R3, =GPIOB_BASE	// Set the address for GPIOB
 80004e8:	4b04      	ldr	r3, [pc, #16]	; (80004fc <num_to_LED+0x2e>)
	MOV R4, #GPIOB_ODR	// Set the offset for the ODR
 80004ea:	f04f 0414 	mov.w	r4, #20
	STR R2, [R3, R4]	// Write the value
 80004ee:	511a      	str	r2, [r3, r4]

	POP {R0-R12, LR}	// Restore registers
 80004f0:	e8bd 5fff 	ldmia.w	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
	BX LR				// Return from subroutine
 80004f4:	4770      	bx	lr
 80004f6:	0000      	.short	0x0000
	LDR R1, =RCC_BASE			// Load the RCC base address
 80004f8:	40023800 	.word	0x40023800
	LDR R1, =GPIOB_BASE 		// Load base address
 80004fc:	40020400 	.word	0x40020400
	LDR R3, =0xFF3FFC00			// Load the output clearing mask
 8000500:	ff3ffc00 	.word	0xff3ffc00
	LDR R3, =0x55155400			// Load the output setting mask
 8000504:	55155400 	.word	0x55155400
	LDR R4, =0xFFFFFC00	// Mask to clear all but lower then bits
 8000508:	fffffc00 	.word	0xfffffc00

0800050c <Key_Init>:
//		R3	-	Masks
// Keypad lives on PC0-PC7
// Row[0] = PC4; Row[3] = PC7
// Col[0] = PC0; Col[3] = PC3
Key_Init:
	PUSH {R1-R3, LR}			// Backup
 800050c:	b50e      	push	{r1, r2, r3, lr}

	LDR R1, =RCC_BASE			// Load RCC base address
 800050e:	495f      	ldr	r1, [pc, #380]	; (800068c <return+0x4>)
	LDR R2, [R1, #RCC_AHB1ENR]	// Read from the RCC AHB1 enable register
 8000510:	6b0a      	ldr	r2, [r1, #48]	; 0x30
	ORR R2, #RCC_GPIOCEN		// Apply mask to enable GPIOC
 8000512:	f042 0204 	orr.w	r2, r2, #4
	STR R2, [R1, #RCC_AHB1ENR]	// Write back to the RCC
 8000516:	630a      	str	r2, [r1, #48]	; 0x30

	LDR R1, =GPIOC_BASE			// Load GPIOC base address
 8000518:	495d      	ldr	r1, [pc, #372]	; (8000690 <return+0x8>)
	LDR R2, [R1, #GPIO_MODER]	// Read from the current mode register
 800051a:	680a      	ldr	r2, [r1, #0]
	MOV R3, #ROW_INPUT			// Load mask to set rows as input
 800051c:	f04f 0355 	mov.w	r3, #85	; 0x55
	BFI R2, R3, #0, #16			// Insert mask where PC0-PC7 live
 8000520:	f363 020f 	bfi	r2, r3, #0, #16
	STR R2, [R1, #GPIO_MODER]	// Write back to the mode register
 8000524:	600a      	str	r2, [r1, #0]

	// R1 still contains GPIOC's base address, so now configure PUPDR

	LDR R2, [R1, #GPIO_PUPDR]	// Read the current pull-up/down register
 8000526:	68ca      	ldr	r2, [r1, #12]
	LDR R3, =0xAAAA				// Load the mask to set our pins to pull-up
 8000528:	f64a 23aa 	movw	r3, #43690	; 0xaaaa
	ORR R2, R3					// Apply mask
 800052c:	ea42 0203 	orr.w	r2, r2, r3
	STR R2, [R1, #GPIO_PUPDR]	// Write back to pull-up/down register
 8000530:	60ca      	str	r2, [r1, #12]

	POP {R1-R3, PC}				// Restore & Return
 8000532:	bd0e      	pop	{r1, r2, r3, pc}

08000534 <Key_GetKey_NoBlock>:
//		R3	-	Column index
//		R4	-	Row index
Key_GetKey_NoBlock:
	// Comments regarding how the keypad was implemented are at
	// the end of the file.
	PUSH {R1-R4, LR}	// backup registers
 8000534:	b51e      	push	{r1, r2, r3, r4, lr}

	// Clear used registers because some BFI's are used
	MOV R0, #0
 8000536:	f04f 0000 	mov.w	r0, #0
	MOV R3, #0
 800053a:	f04f 0300 	mov.w	r3, #0
	MOV R4, #0
 800053e:	f04f 0400 	mov.w	r4, #0

	// Configure rows as inputs, columns as outputs
	LDR R1, =GPIOC_BASE			// Load GPIOC base address
 8000542:	4953      	ldr	r1, [pc, #332]	; (8000690 <return+0x8>)
	LDR R2, [R1, #GPIO_MODER]	// Read from the current mode register
 8000544:	680a      	ldr	r2, [r1, #0]
	MOV R3, #ROW_INPUT			// Load mask to set rows as input
 8000546:	f04f 0355 	mov.w	r3, #85	; 0x55
	BFI R2, R3, #0, #16			// Insert mask where PC0-PC7 live
 800054a:	f363 020f 	bfi	r2, r3, #0, #16
	STR R2, [R1, #GPIO_MODER]	// Write back to the mode register
 800054e:	600a      	str	r2, [r1, #0]

	// Push '1111' onto columns
	LDR R2, [R1, #GPIO_ODR]		// Read current ODR
 8000550:	694a      	ldr	r2, [r1, #20]
	ORR R2, #0xF				// Push 1111
 8000552:	f042 020f 	orr.w	r2, r2, #15
	STR R2, [R1, #GPIO_ODR]		// Write
 8000556:	614a      	str	r2, [r1, #20]

	// Give the electricity time to propogate
	MOV R1, #5
 8000558:	f04f 0105 	mov.w	r1, #5
	BL delay_us
 800055c:	f000 f954 	bl	8000808 <delay_us>

	// Read in rows IDR
	LDR R1, =GPIOC_BASE		// Load GPIOC base address
 8000560:	494b      	ldr	r1, [pc, #300]	; (8000690 <return+0x8>)
	LDR R2, [R1, #GPIO_IDR]	// Read current IDR
 8000562:	690a      	ldr	r2, [r1, #16]
	LSR R2, R2, #4			// Rows are in the upper nibble, so shift right 4 times
 8000564:	ea4f 1212 	mov.w	r2, r2, lsr #4
	BFI R4, R2, #0, #4		// Store value into R4
 8000568:	f362 0403 	bfi	r4, r2, #0, #4

	// Swap rows to outputs and columns as inputs
	LDR R1, =GPIOC_BASE			// Load GPIOC base address
 800056c:	4948      	ldr	r1, [pc, #288]	; (8000690 <return+0x8>)
	LDR R2, [R1, #GPIO_MODER]	// Read from the current mode register
 800056e:	680a      	ldr	r2, [r1, #0]
	MOV R3, #COL_INPUT			// Load mask to set rows as input
 8000570:	f44f 43aa 	mov.w	r3, #21760	; 0x5500
	BFI R2, R3, #0, #16			// Insert mask where PC0-PC7 live
 8000574:	f363 020f 	bfi	r2, r3, #0, #16
	STR R2, [R1, #GPIO_MODER]	// Write back to the mode register
 8000578:	600a      	str	r2, [r1, #0]

	// Push the stored value that was on rows IDR to the ODR
	LDR R1, =GPIOC_BASE			// Load GPIOC base address
 800057a:	4945      	ldr	r1, [pc, #276]	; (8000690 <return+0x8>)
	LDR R2, [R1, #GPIO_ODR]		// Read from the current ODR
 800057c:	694a      	ldr	r2, [r1, #20]
	BFI R2, R4, #4, #4			// Insert into the upper nibble, aka rows
 800057e:	f364 1207 	bfi	r2, r4, #4, #4
	STR R2, [R1, #GPIO_ODR]		// Write back to the ODR
 8000582:	614a      	str	r2, [r1, #20]


	// Give the electricity time to propogate
	MOV R1, #5
 8000584:	f04f 0105 	mov.w	r1, #5
	BL delay_us
 8000588:	f000 f93e 	bl	8000808 <delay_us>

	// Clear R3 because it still has a mask
	MOV R3, #0
 800058c:	f04f 0300 	mov.w	r3, #0

	// Read the column IDR
	LDR R1, =GPIOC_BASE		// Load GPIOC base address
 8000590:	493f      	ldr	r1, [pc, #252]	; (8000690 <return+0x8>)
	LDR R2, [R1, #GPIO_IDR]	// Read the current IDR
 8000592:	690a      	ldr	r2, [r1, #16]
	BFI R3, R2, #0, #4		// Store the upper nibble
 8000594:	f362 0303 	bfi	r3, r2, #0, #4

	MOV R1, R3
 8000598:	4619      	mov	r1, r3
	MOV R2, R4
 800059a:	4622      	mov	r2, r4
	BL IndexToNum
 800059c:	f000 f81c 	bl	80005d8 <IndexToNum>

	POP {R1-R4, PC}
 80005a0:	bd1e      	pop	{r1, r2, r3, r4, pc}

080005a2 <Key_GetKey>:
//		R1	-	Subroutine arguments
//		R2	-	Backup copy of the button code
Key_GetKey:
// Similar to GetKey_NoBlock, but waits for a key to be pressed to return.
// Basically just continuiously call the NoBlock method while it returns 0.
	PUSH {R1-R2, LR}
 80005a2:	b506      	push	{r1, r2, lr}
	1:
		// Delay 10ms for debouncing
		MOV R1, #10
 80005a4:	f04f 010a 	mov.w	r1, #10
		BL delay_ms
 80005a8:	f000 f91c 	bl	80007e4 <delay_ms>

		// Check if there's a key being pressed
		BL Key_GetKey_NoBlock
 80005ac:	f7ff ffc2 	bl	8000534 <Key_GetKey_NoBlock>

		// Compare to 0 as it means no buttons being pressed
		// If there isn't a button being pressed, loop.
		CMP R0, #0
 80005b0:	2800      	cmp	r0, #0
		BEQ 1b
 80005b2:	d0f7      	beq.n	80005a4 <Key_GetKey+0x2>
		MOV R2, R0
 80005b4:	4602      	mov	r2, r0
	1:
		// Delay 10ms for debouncing
		MOV R1, #10
 80005b6:	f04f 010a 	mov.w	r1, #10
		BL delay_ms
 80005ba:	f000 f913 	bl	80007e4 <delay_ms>

		BL Key_GetKey_NoBlock
 80005be:	f7ff ffb9 	bl	8000534 <Key_GetKey_NoBlock>

		CMP R0, #0
 80005c2:	2800      	cmp	r0, #0
		BNE 1b
 80005c4:	d1f7      	bne.n	80005b6 <Key_GetKey+0x14>

		MOV R0, R2
 80005c6:	4610      	mov	r0, r2

	POP {R1-R2, PC}
 80005c8:	bd06      	pop	{r1, r2, pc}

080005ca <Key_GetChar>:
//	Register Use:
//		R0	-	Return value
//		R1	-	Subroutine arguments
//		R2	-	Array address
Key_GetChar:
	PUSH {R1-R2, LR}
 80005ca:	b506      	push	{r1, r2, lr}

	BL Key_GetKey
 80005cc:	f7ff ffe9 	bl	80005a2 <Key_GetKey>

	MOV R1, R0
 80005d0:	4601      	mov	r1, r0

	LDR R2, =chars
 80005d2:	4a30      	ldr	r2, [pc, #192]	; (8000694 <return+0xc>)
	LDRB R0, [R2, R1]
 80005d4:	5c50      	ldrb	r0, [r2, r1]

	POP {R1-R2, PC}
 80005d6:	bd06      	pop	{r1, r2, pc}

080005d8 <IndexToNum>:
//	Register Use:
//		R0	-	Return
//		R1	-	Argument
//		R2	-	Argument
IndexToNum:
	PUSH {LR}
 80005d8:	b500      	push	{lr}

	CMP R1, #0b0001		// First column case
 80005da:	2901      	cmp	r1, #1
	BEQ column1
 80005dc:	d008      	beq.n	80005f0 <column1>

	CMP R1, #0b0010		// Second column case
 80005de:	2902      	cmp	r1, #2
	BEQ column2
 80005e0:	d019      	beq.n	8000616 <column2>

	CMP R1, #0b0100		// Third column case
 80005e2:	2904      	cmp	r1, #4
	BEQ column3
 80005e4:	d02a      	beq.n	800063c <column3>

	CMP R1, #0b1000		// Fourth column case
 80005e6:	2908      	cmp	r1, #8
	BEQ column4
 80005e8:	d03b      	beq.n	8000662 <column4>

	// Default case; only 16 buttons on our keypad.
	MOV R0, #0
 80005ea:	f04f 0000 	mov.w	r0, #0
	B return
 80005ee:	e04b      	b.n	8000688 <return>

080005f0 <column1>:

	column1:
		CMP R2, #0b0001		// First row case
 80005f0:	2a01      	cmp	r2, #1
		IT EQ
 80005f2:	bf08      	it	eq
			MOVEQ R0, #1		// Column 1, Row 1
 80005f4:	2001      	moveq	r0, #1
			BEQ return
 80005f6:	d047      	beq.n	8000688 <return>
		CMP R2, #0b0010		// Second row case
 80005f8:	2a02      	cmp	r2, #2
		IT EQ
 80005fa:	bf08      	it	eq
			MOVEQ R0, #4		// Column 1, Row 2
 80005fc:	2004      	moveq	r0, #4
			BEQ return
 80005fe:	d043      	beq.n	8000688 <return>
		CMP R2, #0b0100		// Third row case
 8000600:	2a04      	cmp	r2, #4
		IT EQ
 8000602:	bf08      	it	eq
			MOVEQ R0, #7		// Column 1, Row 3
 8000604:	2007      	moveq	r0, #7
			BEQ return
 8000606:	d03f      	beq.n	8000688 <return>
		CMP R2, #0b1000		// Fourth row case
 8000608:	2a08      	cmp	r2, #8
		IT EQ
 800060a:	bf08      	it	eq
			MOVEQ R0, #0xF		// Column 1, Row 4
 800060c:	200f      	moveq	r0, #15
			BEQ return
 800060e:	d03b      	beq.n	8000688 <return>

		// Default case; only 16 buttons on our keypad.
		MOV R0, #0
 8000610:	f04f 0000 	mov.w	r0, #0
		B return
 8000614:	e038      	b.n	8000688 <return>

08000616 <column2>:

	column2:
		CMP R2, #0b0001		// First row case
 8000616:	2a01      	cmp	r2, #1
		IT EQ
 8000618:	bf08      	it	eq
			MOVEQ R0, #2		// Column 2, Row 1
 800061a:	2002      	moveq	r0, #2
			BEQ return
 800061c:	d034      	beq.n	8000688 <return>
		CMP R2, #0b0010		// Second row case
 800061e:	2a02      	cmp	r2, #2
		IT EQ
 8000620:	bf08      	it	eq
			MOVEQ R0, #5		// Column 2, Row 2
 8000622:	2005      	moveq	r0, #5
			BEQ return
 8000624:	d030      	beq.n	8000688 <return>
		CMP R2, #0b0100		// Third row case
 8000626:	2a04      	cmp	r2, #4
		IT EQ
 8000628:	bf08      	it	eq
			MOVEQ R0, #8		// Column 2, Row 3
 800062a:	2008      	moveq	r0, #8
			BEQ return
 800062c:	d02c      	beq.n	8000688 <return>
		CMP R2, #0b1000		// Fourth row case
 800062e:	2a08      	cmp	r2, #8
		IT EQ
 8000630:	bf08      	it	eq
			MOVEQ R0, #16		// Column 2, Row 4
 8000632:	2010      	moveq	r0, #16
			BEQ return
 8000634:	d028      	beq.n	8000688 <return>

		// Default case; only 16 buttons on our keypad.
		MOV R0, #0
 8000636:	f04f 0000 	mov.w	r0, #0
		B return
 800063a:	e025      	b.n	8000688 <return>

0800063c <column3>:

	column3:
		CMP R2, #0b0001		// First row case
 800063c:	2a01      	cmp	r2, #1
		IT EQ
 800063e:	bf08      	it	eq
			MOVEQ R0, #3		// Column 3, Row 1
 8000640:	2003      	moveq	r0, #3
			BEQ return
 8000642:	d021      	beq.n	8000688 <return>
		CMP R2, #0b0010		// Second row case
 8000644:	2a02      	cmp	r2, #2
		IT EQ
 8000646:	bf08      	it	eq
			MOVEQ R0, #6		// Column 3, Row 2
 8000648:	2006      	moveq	r0, #6
			BEQ return
 800064a:	d01d      	beq.n	8000688 <return>
		CMP R2, #0b0100		// Third row case
 800064c:	2a04      	cmp	r2, #4
		IT EQ
 800064e:	bf08      	it	eq
			MOVEQ R0, #9		// Column 3, Row 3
 8000650:	2009      	moveq	r0, #9
			BEQ return
 8000652:	d019      	beq.n	8000688 <return>
		CMP R2, #0b1000		// Fourth row case
 8000654:	2a08      	cmp	r2, #8
		IT EQ
 8000656:	bf08      	it	eq
			MOVEQ R0, #0xE		// Column 3, Row 4
 8000658:	200e      	moveq	r0, #14
			BEQ return
 800065a:	d015      	beq.n	8000688 <return>

		// Default case; only 16 buttons on our keypad.
		MOV R0, #0
 800065c:	f04f 0000 	mov.w	r0, #0
		B return
 8000660:	e012      	b.n	8000688 <return>

08000662 <column4>:

	column4:
		CMP R2, #0b0001		// First row case
 8000662:	2a01      	cmp	r2, #1
		IT EQ
 8000664:	bf08      	it	eq
			MOVEQ R0, #0xA		// Column 4, Row 1
 8000666:	200a      	moveq	r0, #10
			BEQ return
 8000668:	d00e      	beq.n	8000688 <return>
		CMP R2, #0b0010		// Second row case
 800066a:	2a02      	cmp	r2, #2
		IT EQ
 800066c:	bf08      	it	eq
			MOVEQ R0, #0xB		// Column 4, Row 2
 800066e:	200b      	moveq	r0, #11
			BEQ return
 8000670:	d00a      	beq.n	8000688 <return>
		CMP R2, #0b0100		// Third row case
 8000672:	2a04      	cmp	r2, #4
		IT EQ
 8000674:	bf08      	it	eq
			MOVEQ R0, #0xC		// Column 4, Row 3
 8000676:	200c      	moveq	r0, #12
			BEQ return
 8000678:	d006      	beq.n	8000688 <return>
		CMP R2, #0b1000		// Fourth row case
 800067a:	2a08      	cmp	r2, #8
		IT EQ
 800067c:	bf08      	it	eq
			MOVEQ R0, #0xD		// Column 4, Row 4
 800067e:	200d      	moveq	r0, #13
			BEQ return
 8000680:	d002      	beq.n	8000688 <return>

		// Default case; only 16 buttons on our keypad.
		MOV R0, #0
 8000682:	f04f 0000 	mov.w	r0, #0
		B return
 8000686:	e7ff      	b.n	8000688 <return>

08000688 <return>:

	return:
		POP {PC}
 8000688:	bd00      	pop	{pc}
 800068a:	0000      	.short	0x0000
	LDR R1, =RCC_BASE			// Load RCC base address
 800068c:	40023800 	.word	0x40023800
	LDR R1, =GPIOC_BASE			// Load GPIOC base address
 8000690:	40020800 	.word	0x40020800
	LDR R2, =chars
 8000694:	080009f4 	.word	0x080009f4

08000698 <main>:

.global main

main:
	// Initialization
	BL delay_Init
 8000698:	f000 f892 	bl	80007c0 <delay_Init>
	BL LCD_Init
 800069c:	f7ff fe6f 	bl	800037e <LCD_Init>
	BL Key_Init
 80006a0:	f7ff ff34 	bl	800050c <Key_Init>
	BL LED_Init
 80006a4:	f7ff ff00 	bl	80004a8 <LED_Init>
	BL Tone_Setup
 80006a8:	f000 f8d6 	bl	8000858 <Tone_Setup>

	// Startup Messages
	BL startup
 80006ac:	f000 f852 	bl	8000754 <startup>

	// String size iterator
	MOV R7, #0
 80006b0:	f04f 0700 	mov.w	r7, #0

	// Line position
	MOV R6, #0
 80006b4:	f04f 0600 	mov.w	r6, #0

080006b8 <loop>:

loop:
	BL Key_GetChar		// Get character that was pressed
 80006b8:	f7ff ff87 	bl	80005ca <Key_GetChar>
	MOV R1, R0			// Move into argument register
 80006bc:	4601      	mov	r1, r0

	CMP R1, #0x2A		// Compare to the char 0x2A, AKA '*'
 80006be:	292a      	cmp	r1, #42	; 0x2a
	IT EQ
 80006c0:	bf08      	it	eq
		BEQ clear		// If the character was '*', clear entry
 80006c2:	e036      	beq.n	8000732 <clear>

	CMP R1, #0x23		// Compare to the char 0x23, AKA '#'
 80006c4:	2923      	cmp	r1, #35	; 0x23
	BEQ compare			// If the character was '#', compare to the actual code
 80006c6:	d00d      	beq.n	80006e4 <compare>

	CMP R7, #LINE_MAX	// Compare string length to display width
 80006c8:	2f10      	cmp	r7, #16
	IT EQ
 80006ca:	bf08      	it	eq
		BLEQ newline	// If there are 16 chars on display, start a new line
 80006cc:	f000 f827 	bleq	800071e <newline>

	CMP R7, #STRING_MAX	// Compare string to max width
 80006d0:	2f20      	cmp	r7, #32
	BEQ compare			// If the string is at max size, compare to the actual code
 80006d2:	d007      	beq.n	80006e4 <compare>

	// If none of the above comparisons trigger, print the char and update entry
	BL LCD_PrintChar	// Print the character
 80006d4:	f7ff fedc 	bl	8000490 <LCD_PrintChar>
	LDR R0, =ENTRY		// Load entry address
 80006d8:	4831      	ldr	r0, [pc, #196]	; (80007a0 <startup+0x4c>)
	STRB R1, [R0, R7]	// Store the char at the current index
 80006da:	55c1      	strb	r1, [r0, r7]
	ADD R7, #1			// Increment string size
 80006dc:	f107 0701 	add.w	r7, r7, #1

	B loop
 80006e0:	e7ea      	b.n	80006b8 <loop>

080006e2 <end>:

end: B end
 80006e2:	e7fe      	b.n	80006e2 <end>

080006e4 <compare>:

compare:

	// Use my string comparison method in ASCII.S to
	// compare the user entry to the actual code
	LDR R1, =CODE			// Load the address for the actual code
 80006e4:	492f      	ldr	r1, [pc, #188]	; (80007a4 <startup+0x50>)
	LDR R2, =ENTRY			// Load the address for the user entry
 80006e6:	4a2e      	ldr	r2, [pc, #184]	; (80007a0 <startup+0x4c>)
	BL ASCII_StringCompare	// Compare the two
 80006e8:	f7ff fdcd 	bl	8000286 <ASCII_StringCompare>

	MOV R2, #0				// Clear success/fail light
 80006ec:	f04f 0200 	mov.w	r2, #0

	CMP R0, #0				// Compare the results of string comparison to 0, aka equal
 80006f0:	2800      	cmp	r0, #0
	ITTT EQ
 80006f2:	bf02      	ittt	eq
		LDREQ R1, =good		// If they were equal, load the success message
 80006f4:	492c      	ldreq	r1, [pc, #176]	; (80007a8 <startup+0x54>)
		MOVEQ R2, #1		// If equal, prep success LED
 80006f6:	2201      	moveq	r2, #1
		BLEQ Tone_Success	// Play the success tone
 80006f8:	f000 f8d5 	bleq	80008a6 <Tone_Success>

	CMP R0, #0		// Playing success tone updates CPSR so redo comparison
 80006fc:	2800      	cmp	r0, #0

	ITT NE
 80006fe:	bf1c      	itt	ne
		LDRNE R1, =fail		// If they weren't equal, load the fail message
 8000700:	492a      	ldrne	r1, [pc, #168]	; (80007ac <startup+0x58>)
		BLNE Tone_Failure	// Play the failure tone
 8000702:	f000 f8f3 	blne	80008ec <Tone_Failure>

	BL LCD_Clear
 8000706:	f7ff fe66 	bl	80003d6 <LCD_Clear>
	BL LCD_PrintString		// Print the success/fail message
 800070a:	f7ff fe8d 	bl	8000428 <LCD_PrintString>
	MOV R1, R2				// Prep to display success/fail LED
 800070e:	4611      	mov	r1, r2
	BL num_to_LED			// Display success/fail LED
 8000710:	f7ff fedd 	bl	80004ce <num_to_LED>

	// 3 second delay
	MOV R1, #3
 8000714:	f04f 0103 	mov.w	r1, #3
	BL delay_sec
 8000718:	f000 f888 	bl	800082c <delay_sec>

	// Clear entry
	B clear
 800071c:	e009      	b.n	8000732 <clear>

0800071e <newline>:



newline:
	PUSH {R0, R1, LR}
 800071e:	b503      	push	{r0, r1, lr}

	CMP R6, #0				// Determine which line we are on
 8000720:	2e00      	cmp	r6, #0
	ITTTT EQ				// If on first line
 8000722:	bf01      	itttt	eq
		MOVEQ R0, #1		// Second line
 8000724:	2001      	moveq	r0, #1
		MOVEQ R1, #0		// First column
 8000726:	2100      	moveq	r1, #0
		MOVEQ R6, #1		// Update line counter
 8000728:	2601      	moveq	r6, #1
		BLEQ LCD_MoveCursor	// Move cursor
 800072a:	f7ff fe68 	bleq	80003fe <LCD_MoveCursor>

	POP {R0, R1, LR}
 800072e:	e8bd 4003 	ldmia.w	sp!, {r0, r1, lr}

08000732 <clear>:

clear:
	PUSH {R0, R1, R2}
 8000732:	b407      	push	{r0, r1, r2}
	MOV R0, #0			// Iterator
 8000734:	f04f 0000 	mov.w	r0, #0
	MOV R2, #0			// Clear value
 8000738:	f04f 0200 	mov.w	r2, #0
	LDR R1, =ENTRY		// Entry address
 800073c:	4918      	ldr	r1, [pc, #96]	; (80007a0 <startup+0x4c>)

	1:
	STRB R2, [R1, R0]	// Overwrite 0
 800073e:	540a      	strb	r2, [r1, r0]
	ADD R0, #1			// Increment iterator
 8000740:	f100 0001 	add.w	r0, r0, #1
	SUBS R7, #1			// Decrement string size
 8000744:	3f01      	subs	r7, #1
	BNE 1b				// Loop until string size is negative
 8000746:	d1fa      	bne.n	800073e <clear+0xc>
	MOV R7, #0			// Clear string size
 8000748:	f04f 0700 	mov.w	r7, #0
	BL LCD_Clear		// Clear display
 800074c:	f7ff fe43 	bl	80003d6 <LCD_Clear>
	POP {R0, R1, R2}
 8000750:	bc07      	pop	{r0, r1, r2}
	B loop				// Return to loop
 8000752:	e7b1      	b.n	80006b8 <loop>

08000754 <startup>:

startup:
	PUSH {R0-R1, LR}
 8000754:	b503      	push	{r0, r1, lr}

	// First line of first message
	LDR R1, =msg1_1
 8000756:	4916      	ldr	r1, [pc, #88]	; (80007b0 <startup+0x5c>)
	BL LCD_PrintString
 8000758:	f7ff fe66 	bl	8000428 <LCD_PrintString>

	// Move to second line
	MOV R0, #1
 800075c:	f04f 0001 	mov.w	r0, #1
	MOV R1, #0
 8000760:	f04f 0100 	mov.w	r1, #0
	BL LCD_MoveCursor
 8000764:	f7ff fe4b 	bl	80003fe <LCD_MoveCursor>

	// Second line of first message
	LDR R1, =msg1_2
 8000768:	4912      	ldr	r1, [pc, #72]	; (80007b4 <startup+0x60>)
	BL LCD_PrintString
 800076a:	f7ff fe5d 	bl	8000428 <LCD_PrintString>

	// Wait 5 seconds
	MOV R1, #5
 800076e:	f04f 0105 	mov.w	r1, #5
	BL delay_sec
 8000772:	f000 f85b 	bl	800082c <delay_sec>

	// Clear display
	BL LCD_Clear
 8000776:	f7ff fe2e 	bl	80003d6 <LCD_Clear>

	// First line of second message
	LDR R1, =msg2_1
 800077a:	490f      	ldr	r1, [pc, #60]	; (80007b8 <startup+0x64>)
	BL LCD_PrintString
 800077c:	f7ff fe54 	bl	8000428 <LCD_PrintString>

	// Move to second line
	MOV R0, #1
 8000780:	f04f 0001 	mov.w	r0, #1
	MOV R1, #0
 8000784:	f04f 0100 	mov.w	r1, #0
	BL LCD_MoveCursor
 8000788:	f7ff fe39 	bl	80003fe <LCD_MoveCursor>

	// Second line of second message
	LDR R1, =msg2_2
 800078c:	490b      	ldr	r1, [pc, #44]	; (80007bc <startup+0x68>)
	BL LCD_PrintString
 800078e:	f7ff fe4b 	bl	8000428 <LCD_PrintString>

	// 5 second delay
	MOV R1, #5
 8000792:	f04f 0105 	mov.w	r1, #5
	BL delay_sec
 8000796:	f000 f849 	bl	800082c <delay_sec>

	// Clear display
	BL LCD_Clear
 800079a:	f7ff fe1c 	bl	80003d6 <LCD_Clear>

	// Run rest of program
	POP {R0-R1, PC}
 800079e:	bd03      	pop	{r0, r1, pc}
	LDR R0, =ENTRY		// Load entry address
 80007a0:	20000000 	.word	0x20000000
	LDR R1, =CODE			// Load the address for the actual code
 80007a4:	08000a05 	.word	0x08000a05
		LDREQ R1, =good		// If they were equal, load the success message
 80007a8:	08000a0b 	.word	0x08000a0b
		LDRNE R1, =fail		// If they weren't equal, load the fail message
 80007ac:	08000a14 	.word	0x08000a14
	LDR R1, =msg1_1
 80007b0:	08000a20 	.word	0x08000a20
	LDR R1, =msg1_2
 80007b4:	08000a30 	.word	0x08000a30
	LDR R1, =msg2_1
 80007b8:	08000a3b 	.word	0x08000a3b
	LDR R1, =msg2_2
 80007bc:	08000a4c 	.word	0x08000a4c

080007c0 <delay_Init>:
//		Void
//	Register Usage:
//		R1 	- 	Addresses
//		R2	-	Scratch
delay_Init:
	PUSH {R1-R2, LR}
 80007c0:	b506      	push	{r1, r2, lr}

	// Enable TIM2
	LDR R1, =RCC_BASE		// Load RCC base address
 80007c2:	4923      	ldr	r1, [pc, #140]	; (8000850 <delay_sec+0x24>)
	LDR R2, [R1, #APB1ENR]	// Read
 80007c4:	6c0a      	ldr	r2, [r1, #64]	; 0x40
	ORR R2, #TIM2EN			// Apply Timer 2 enable mask
 80007c6:	f042 0201 	orr.w	r2, r2, #1
	STR R2, [R1, #APB1ENR]	// Write
 80007ca:	640a      	str	r2, [r1, #64]	; 0x40

	// Set timer configurations
	LDR R1, =TIM2_BASE		// Load Timer 2 base address
 80007cc:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
	LDR R2, [R1, #TIM_CR1]	// Read
 80007d0:	680a      	ldr	r2, [r1, #0]
	ORR R2, #OPM_SET		// Apply one pulse mode config
 80007d2:	f042 0208 	orr.w	r2, r2, #8
	ORR R2, #CNT_DN			// Apply countdown config
 80007d6:	f042 0210 	orr.w	r2, r2, #16
	STR R2, [R1, #TIM_CR1]	// Write
 80007da:	600a      	str	r2, [r1, #0]

	// Set prescaler
	MOV R2, #CLK_DIV		// Load desired clock division
 80007dc:	f04f 0210 	mov.w	r2, #16
	STR R2, [R1, #TIM_PSC]	// Apply desired clock division
 80007e0:	628a      	str	r2, [r1, #40]	; 0x28

    POP {R1-R2, PC}
 80007e2:	bd06      	pop	{r1, r2, pc}

080007e4 <delay_ms>:
//	Register Usage:
//		R0	-	Total counts for provided delay
//		R1 	- 	Argument and Addresses
//		R2	-	Scratch
delay_ms:
	PUSH {R0-R2, LR}
 80007e4:	b507      	push	{r0, r1, r2, lr}

	// Convert the argument in milliseconds to counts
	LDR R2, =CNT_MS		// Load the conversion factor
 80007e6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
	MUL R0, R1, R2		// Convert milliseconds to counts
 80007ea:	fb01 f002 	mul.w	r0, r1, r2

	// Store desired count
	LDR R1, =TIM2_BASE		// Load timer base address
 80007ee:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
	STR R0, [R1, #TIM_CNT]	// Overwrite counter
 80007f2:	6248      	str	r0, [r1, #36]	; 0x24

	// Start count
	LDR R2, [R1, #TIM_CR1]	// Load the current control register
 80007f4:	680a      	ldr	r2, [r1, #0]
	ORR R2, #CNTEN_MASK		// Apply mask to enable counter
 80007f6:	f042 0201 	orr.w	r2, r2, #1
	STR R2, [R1, #TIM_CR1]	// Write and start count
 80007fa:	600a      	str	r2, [r1, #0]

	// Poll counter until count expires (counter enable = 0)
	1:
	LDR R2, [R1, #TIM_CR1]	// Read control register
 80007fc:	680a      	ldr	r2, [r1, #0]
	BFC R2, #1, #31			// Clear everything except CEN bit
 80007fe:	f36f 025f 	bfc	r2, #1, #31
	CMP R2, #0				// Compare to 0, aka counter expired
 8000802:	2a00      	cmp	r2, #0
	BNE 1b					// Loop if not zero
 8000804:	d1fa      	bne.n	80007fc <delay_ms+0x18>

	POP {R0-R2, PC}
 8000806:	bd07      	pop	{r0, r1, r2, pc}

08000808 <delay_us>:
//	Register Usage:
//		R0	-	Total counts for provided delay
//		R1 	- 	Argument and Addresses
//		R2	-	Scratch
delay_us:
	PUSH {R0-R2, LR}
 8000808:	b507      	push	{r0, r1, r2, lr}

	// Convert the argument in microseconds to counts
	LDR R2, =CNT_US		// Load the conversion factor (technically 1x but still)
 800080a:	f04f 0201 	mov.w	r2, #1
	MUL R0, R1, R2		// Convert microseconds to counts
 800080e:	fb01 f002 	mul.w	r0, r1, r2

	// Store desired count
	LDR R1, =TIM2_BASE		// Load timer base address
 8000812:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
	STR R0, [R1, #TIM_CNT]	// Overwrite counter
 8000816:	6248      	str	r0, [r1, #36]	; 0x24

	// Start count
	LDR R2, [R1, #TIM_CR1]	// Load the current control register
 8000818:	680a      	ldr	r2, [r1, #0]
	ORR R2, #CNTEN_MASK		// Apply mask to enable counter
 800081a:	f042 0201 	orr.w	r2, r2, #1
	STR R2, [R1, #TIM_CR1]	// Write and start count
 800081e:	600a      	str	r2, [r1, #0]

	// Poll counter until count expires (counter enable = 0)
	1:
	LDR R2, [R1, #TIM_CR1]	// Read control register
 8000820:	680a      	ldr	r2, [r1, #0]
	BFC R2, #1, #31			// Clear everything except CEN bit
 8000822:	f36f 025f 	bfc	r2, #1, #31
	CMP R2, #0				// Compare to 0, aka counter expired
 8000826:	2a00      	cmp	r2, #0
	BNE 1b					// Loop if not zero
 8000828:	d1fa      	bne.n	8000820 <delay_us+0x18>

	POP {R0-R2, PC}
 800082a:	bd07      	pop	{r0, r1, r2, pc}

0800082c <delay_sec>:
//	Register Usage:
//		R0	-	Total counts for provided delay
//		R1 	- 	Argument and Addresses
//		R2	-	Scratch
delay_sec:
	PUSH {R0-R2, LR}
 800082c:	b507      	push	{r0, r1, r2, lr}

	// Convert the argument in seconds to counts
	LDR R2, =CNT_S		// Load the conversion factor
 800082e:	4a09      	ldr	r2, [pc, #36]	; (8000854 <delay_sec+0x28>)
	MUL R0, R1, R2		// Convert seconds to counts
 8000830:	fb01 f002 	mul.w	r0, r1, r2

	// Store desired count
	LDR R1, =TIM2_BASE		// Load timer base address
 8000834:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
	STR R0, [R1, #TIM_CNT]	// Overwrite counter
 8000838:	6248      	str	r0, [r1, #36]	; 0x24

	// Start count
	LDR R2, [R1, #TIM_CR1]	// Load the current control register
 800083a:	680a      	ldr	r2, [r1, #0]
	ORR R2, #CNTEN_MASK		// Apply mask to enable counter
 800083c:	f042 0201 	orr.w	r2, r2, #1
	STR R2, [R1, #TIM_CR1]	// Write and start count
 8000840:	600a      	str	r2, [r1, #0]

	// Poll counter until count expires (counter enable = 0)
	1:
	LDR R2, [R1, #TIM_CR1]	// Read control register
 8000842:	680a      	ldr	r2, [r1, #0]
	BFC R2, #1, #31			// Clear everything except CEN bit
 8000844:	f36f 025f 	bfc	r2, #1, #31
	CMP R2, #0				// Compare to 0, aka counter expired
 8000848:	2a00      	cmp	r2, #0
	BNE 1b					// Loop if not zero
 800084a:	d1fa      	bne.n	8000842 <delay_sec+0x16>

	POP {R0-R2, PC}
 800084c:	bd07      	pop	{r0, r1, r2, pc}
 800084e:	0000      	.short	0x0000
	LDR R1, =RCC_BASE		// Load RCC base address
 8000850:	40023800 	.word	0x40023800
	LDR R2, =CNT_S		// Load the conversion factor
 8000854:	000f4240 	.word	0x000f4240

08000858 <Tone_Setup>:
//		R0	-	Scratch
//		R1	-	Addresses
//		R2	-	Scratch
//		R3	-	Scratch
Tone_Setup:
	PUSH {R0-R3, LR}
 8000858:	b50f      	push	{r0, r1, r2, r3, lr}

	// Enable GPIOB
	LDR R1, =RCC_BASE		// Load RCC base addr
 800085a:	4936      	ldr	r1, [pc, #216]	; (8000934 <Tone_Failure+0x48>)
	LDR R2, [R1, #AHB1ENR]	// Read from the AHB1ENR
 800085c:	6b0a      	ldr	r2, [r1, #48]	; 0x30
	ORR R2, #GPIOBEN		// Apply GPIOB enable mask
 800085e:	f042 0202 	orr.w	r2, r2, #2
	STR R2, [R1, #AHB1ENR]	// Write back to AHB1ENR
 8000862:	630a      	str	r2, [r1, #48]	; 0x30

	// Enable TIM3 (enabler also lives in RCC)
	LDR R2, [R1, #APB1ENR]	// Read from the APB1 enable register
 8000864:	6c0a      	ldr	r2, [r1, #64]	; 0x40
	ORR R2, #TIM3EN			// Apply timer 3 enable mask
 8000866:	f042 0202 	orr.w	r2, r2, #2
	STR R2, [R1, #APB1ENR]	// Write back to APB1ENR
 800086a:	640a      	str	r2, [r1, #64]	; 0x40

	// Set PB4 as alternate funct
	LDR R1, =GPIOB_BASE				// Load GPIOB base address
 800086c:	4932      	ldr	r1, [pc, #200]	; (8000938 <Tone_Failure+0x4c>)
	LDR R2, [R1, #GPIO_MODER]		// Read the mode register
 800086e:	680a      	ldr	r2, [r1, #0]
	ORR R2, #GPIO_ALTFUN << (4 * 2)	// Apply the 2 bit mask to PB4
 8000870:	f442 7200 	orr.w	r2, r2, #512	; 0x200
	STR R2, [R1, #GPIO_MODER]		// Write
 8000874:	600a      	str	r2, [r1, #0]

	// Set alternate function register for PB4
	// PB4 AFR is AFRL [19..16]
	// TIM3_CH1 is alternate function 2
	LDR R2, [R1, #GPIO_AFRL]	// Read current AFRL
 8000876:	6a0a      	ldr	r2, [r1, #32]
	MOV R0, #PB4_ALTFUN			// Load mask for BFI
 8000878:	f04f 0002 	mov.w	r0, #2
	BFI R2, R0, #16, #4			// Insert the alt. funct. code into AFRL4
 800087c:	f360 4213 	bfi	r2, r0, #16, #4
	STR R2, [R1, #GPIO_AFRL]	// Write
 8000880:	620a      	str	r2, [r1, #32]

	// Update timer prescaler
	LDR R1, =TIM3_BASE
 8000882:	492e      	ldr	r1, [pc, #184]	; (800093c <Tone_Failure+0x50>)
	MOV R2, #PRESCALE
 8000884:	f04f 0210 	mov.w	r2, #16
	STR R2, [R1, #TIM_PSC]
 8000888:	628a      	str	r2, [r1, #40]	; 0x28

	// Configure capture/compare mode register (CCMR)
	// Set output mode to toggle
	// Disable preload
	LDR R1, =TIM3_BASE			// Load Timer 3 base addr
 800088a:	492c      	ldr	r1, [pc, #176]	; (800093c <Tone_Failure+0x50>)
	LDR R2, [R1, #TIM_CCMR1]	// Read from the CCMR
 800088c:	698a      	ldr	r2, [r1, #24]
	MOV R3, #PIN_TOGGLE			// Load toggle output mode
 800088e:	f04f 0303 	mov.w	r3, #3
	BFI R2, R3, #4, #3			// Insert toggle command
 8000892:	f363 1206 	bfi	r2, r3, #4, #3
	BFC	R2, #3, #1				// Clear (disable) preload
 8000896:	f36f 02c3 	bfc	r2, #3, #1
	STR R2, [R1, #TIM_CCMR1]
 800089a:	618a      	str	r2, [r1, #24]

	// Set CC1E (capture compare ch1 enable)
	// Set CC1P (capture compare ch1 polarity)
	LDR R2, [R1, #TIM_CCER]	// Read
 800089c:	6a0a      	ldr	r2, [r1, #32]
	ORR R2, #0b11 << 0		// CC1E & CC1P live at CCER[1..0]
 800089e:	f042 0203 	orr.w	r2, r2, #3
	STR R2, [R1, #TIM_CCER]	// Write
 80008a2:	620a      	str	r2, [r1, #32]

	POP {R0-R3, PC}
 80008a4:	bd0f      	pop	{r0, r1, r2, r3, pc}

080008a6 <Tone_Success>:
//	Register Use:
//		R1	-	Delay arguments
//		R2	-	Scratch
//		R3	-	Address
Tone_Success:
	PUSH {R1-R3, LR}
 80008a6:	b50e      	push	{r1, r2, r3, lr}

	// Load base address
	LDR R3, =TIM3_BASE
 80008a8:	4b24      	ldr	r3, [pc, #144]	; (800093c <Tone_Failure+0x50>)


	// Write first frequency
	MOV R2, #NOTE_C5
 80008aa:	f240 7277 	movw	r2, #1911	; 0x777
	STR R2, [R3, #TIM_ARR]
 80008ae:	62da      	str	r2, [r3, #44]	; 0x2c
	STR R2, [R3, #TIM_CCR]
 80008b0:	635a      	str	r2, [r3, #52]	; 0x34

	// Turn on clock
	LDR R2, [R3, #TIM_CR1]
 80008b2:	681a      	ldr	r2, [r3, #0]
	ORR R2, #1
 80008b4:	f042 0201 	orr.w	r2, r2, #1
	STR R2, [R3, #TIM_CR1]
 80008b8:	601a      	str	r2, [r3, #0]

	// Play note for the desired length
	MOV R1, #NOTE_LEN
 80008ba:	f04f 01c8 	mov.w	r1, #200	; 0xc8
	BL delay_ms
 80008be:	f7ff ff91 	bl	80007e4 <delay_ms>

	// Turn off clock
	LDR R2, [R3, #TIM_CR1]
 80008c2:	681a      	ldr	r2, [r3, #0]
	BFC R2, #0, #1
 80008c4:	f36f 0200 	bfc	r2, #0, #1
	STR R2, [R3, #TIM_CR1]
 80008c8:	601a      	str	r2, [r3, #0]

	// Write second frequency
	MOV R2, #NOTE_G5
 80008ca:	f240 42fc 	movw	r2, #1276	; 0x4fc
	STR R2, [R3, #TIM_ARR]
 80008ce:	62da      	str	r2, [r3, #44]	; 0x2c
	STR R2, [R3, #TIM_CCR]
 80008d0:	635a      	str	r2, [r3, #52]	; 0x34

	// Turn on clock
	LDR R2, [R3, #TIM_CR1]
 80008d2:	681a      	ldr	r2, [r3, #0]
	ORR R2, #1
 80008d4:	f042 0201 	orr.w	r2, r2, #1
	STR R2, [R3, #TIM_CR1]
 80008d8:	601a      	str	r2, [r3, #0]

	// Play note for the desired length
	MOV R1, #NOTE_LEN
 80008da:	f04f 01c8 	mov.w	r1, #200	; 0xc8
	BL delay_ms
 80008de:	f7ff ff81 	bl	80007e4 <delay_ms>

	// Turn off clock
	LDR R2, [R3, #TIM_CR1]
 80008e2:	681a      	ldr	r2, [r3, #0]
	BFC R2, #0, #1
 80008e4:	f36f 0200 	bfc	r2, #0, #1
	STR R2, [R3, #TIM_CR1]
 80008e8:	601a      	str	r2, [r3, #0]

	POP {R1-R3, PC}
 80008ea:	bd0e      	pop	{r1, r2, r3, pc}

080008ec <Tone_Failure>:
//	Register Use:
//		R1	-	Delay arguments
//		R2	-	Scratch
//		R3	-	Address
Tone_Failure:
	PUSH {R1-R3, LR}
 80008ec:	b50e      	push	{r1, r2, r3, lr}

	// Load base address
	LDR R3, =TIM3_BASE
 80008ee:	4b13      	ldr	r3, [pc, #76]	; (800093c <Tone_Failure+0x50>)


	// Write first frequency
	MOV R2, #NOTE_G5
 80008f0:	f240 42fc 	movw	r2, #1276	; 0x4fc
	STR R2, [R3, #TIM_ARR]
 80008f4:	62da      	str	r2, [r3, #44]	; 0x2c
	STR R2, [R3, #TIM_CCR]
 80008f6:	635a      	str	r2, [r3, #52]	; 0x34

	// Turn on clock
	LDR R2, [R3, #TIM_CR1]
 80008f8:	681a      	ldr	r2, [r3, #0]
	ORR R2, #1
 80008fa:	f042 0201 	orr.w	r2, r2, #1
	STR R2, [R3, #TIM_CR1]
 80008fe:	601a      	str	r2, [r3, #0]

	// Play note for the desired length
	MOV R1, #NOTE_LEN
 8000900:	f04f 01c8 	mov.w	r1, #200	; 0xc8
	BL delay_ms
 8000904:	f7ff ff6e 	bl	80007e4 <delay_ms>

	// Turn off clock
	LDR R2, [R3, #TIM_CR1]
 8000908:	681a      	ldr	r2, [r3, #0]
	BFC R2, #0, #1
 800090a:	f36f 0200 	bfc	r2, #0, #1
	STR R2, [R3, #TIM_CR1]
 800090e:	601a      	str	r2, [r3, #0]

	// Write second frequency
	MOV R2, #NOTE_C5
 8000910:	f240 7277 	movw	r2, #1911	; 0x777
	STR R2, [R3, #TIM_ARR]
 8000914:	62da      	str	r2, [r3, #44]	; 0x2c
	STR R2, [R3, #TIM_CCR]
 8000916:	635a      	str	r2, [r3, #52]	; 0x34

	// Turn on clock
	LDR R2, [R3, #TIM_CR1]
 8000918:	681a      	ldr	r2, [r3, #0]
	ORR R2, #1
 800091a:	f042 0201 	orr.w	r2, r2, #1
	STR R2, [R3, #TIM_CR1]
 800091e:	601a      	str	r2, [r3, #0]

	// Play note for the desired length
	MOV R1, #NOTE_LEN
 8000920:	f04f 01c8 	mov.w	r1, #200	; 0xc8
	BL delay_ms
 8000924:	f7ff ff5e 	bl	80007e4 <delay_ms>

	// Turn off clock
	LDR R2, [R3, #TIM_CR1]
 8000928:	681a      	ldr	r2, [r3, #0]
	BFC R2, #0, #1
 800092a:	f36f 0200 	bfc	r2, #0, #1
	STR R2, [R3, #TIM_CR1]
 800092e:	601a      	str	r2, [r3, #0]

	POP {R1-R3, PC}
 8000930:	bd0e      	pop	{r1, r2, r3, pc}
 8000932:	0000      	.short	0x0000
	LDR R1, =RCC_BASE		// Load RCC base addr
 8000934:	40023800 	.word	0x40023800
	LDR R1, =GPIOB_BASE				// Load GPIOB base address
 8000938:	40020400 	.word	0x40020400
	LDR R1, =TIM3_BASE
 800093c:	40000400 	.word	0x40000400

08000940 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8000940:	480d      	ldr	r0, [pc, #52]	; (8000978 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8000942:	4685      	mov	sp, r0
/* Call the clock system intitialization function.*/
  bl  SystemInit
 8000944:	f3af 8000 	nop.w

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8000948:	480c      	ldr	r0, [pc, #48]	; (800097c <LoopForever+0x6>)
  ldr r1, =_edata
 800094a:	490d      	ldr	r1, [pc, #52]	; (8000980 <LoopForever+0xa>)
  ldr r2, =_sidata
 800094c:	4a0d      	ldr	r2, [pc, #52]	; (8000984 <LoopForever+0xe>)
  movs r3, #0
 800094e:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8000950:	e002      	b.n	8000958 <LoopCopyDataInit>

08000952 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8000952:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8000954:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8000956:	3304      	adds	r3, #4

08000958 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8000958:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800095a:	428c      	cmp	r4, r1
  bcc CopyDataInit
 800095c:	d3f9      	bcc.n	8000952 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800095e:	4a0a      	ldr	r2, [pc, #40]	; (8000988 <LoopForever+0x12>)
  ldr r4, =_ebss
 8000960:	4c0a      	ldr	r4, [pc, #40]	; (800098c <LoopForever+0x16>)
  movs r3, #0
 8000962:	2300      	movs	r3, #0
  b LoopFillZerobss
 8000964:	e001      	b.n	800096a <LoopFillZerobss>

08000966 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8000966:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8000968:	3204      	adds	r2, #4

0800096a <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800096a:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800096c:	d3fb      	bcc.n	8000966 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 800096e:	f000 f811 	bl	8000994 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8000972:	f7ff fe91 	bl	8000698 <main>

08000976 <LoopForever>:

LoopForever:
    b LoopForever
 8000976:	e7fe      	b.n	8000976 <LoopForever>
  ldr   r0, =_estack
 8000978:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 800097c:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8000980:	20000004 	.word	0x20000004
  ldr r2, =_sidata
 8000984:	08000a68 	.word	0x08000a68
  ldr r2, =_sbss
 8000988:	20000004 	.word	0x20000004
  ldr r4, =_ebss
 800098c:	20000020 	.word	0x20000020

08000990 <ADC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8000990:	e7fe      	b.n	8000990 <ADC_IRQHandler>
	...

08000994 <__libc_init_array>:
 8000994:	b570      	push	{r4, r5, r6, lr}
 8000996:	4d0d      	ldr	r5, [pc, #52]	; (80009cc <__libc_init_array+0x38>)
 8000998:	4c0d      	ldr	r4, [pc, #52]	; (80009d0 <__libc_init_array+0x3c>)
 800099a:	1b64      	subs	r4, r4, r5
 800099c:	10a4      	asrs	r4, r4, #2
 800099e:	2600      	movs	r6, #0
 80009a0:	42a6      	cmp	r6, r4
 80009a2:	d109      	bne.n	80009b8 <__libc_init_array+0x24>
 80009a4:	4d0b      	ldr	r5, [pc, #44]	; (80009d4 <__libc_init_array+0x40>)
 80009a6:	4c0c      	ldr	r4, [pc, #48]	; (80009d8 <__libc_init_array+0x44>)
 80009a8:	f000 f818 	bl	80009dc <_init>
 80009ac:	1b64      	subs	r4, r4, r5
 80009ae:	10a4      	asrs	r4, r4, #2
 80009b0:	2600      	movs	r6, #0
 80009b2:	42a6      	cmp	r6, r4
 80009b4:	d105      	bne.n	80009c2 <__libc_init_array+0x2e>
 80009b6:	bd70      	pop	{r4, r5, r6, pc}
 80009b8:	f855 3b04 	ldr.w	r3, [r5], #4
 80009bc:	4798      	blx	r3
 80009be:	3601      	adds	r6, #1
 80009c0:	e7ee      	b.n	80009a0 <__libc_init_array+0xc>
 80009c2:	f855 3b04 	ldr.w	r3, [r5], #4
 80009c6:	4798      	blx	r3
 80009c8:	3601      	adds	r6, #1
 80009ca:	e7f2      	b.n	80009b2 <__libc_init_array+0x1e>
 80009cc:	08000a60 	.word	0x08000a60
 80009d0:	08000a60 	.word	0x08000a60
 80009d4:	08000a60 	.word	0x08000a60
 80009d8:	08000a64 	.word	0x08000a64

080009dc <_init>:
 80009dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80009de:	bf00      	nop
 80009e0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80009e2:	bc08      	pop	{r3}
 80009e4:	469e      	mov	lr, r3
 80009e6:	4770      	bx	lr

080009e8 <_fini>:
 80009e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80009ea:	bf00      	nop
 80009ec:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80009ee:	bc08      	pop	{r3}
 80009f0:	469e      	mov	lr, r3
 80009f2:	4770      	bx	lr
